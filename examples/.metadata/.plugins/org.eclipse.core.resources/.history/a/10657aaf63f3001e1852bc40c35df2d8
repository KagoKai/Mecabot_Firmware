#include <cstdint>
#include "mainpp.h"
#include "mecabot_hardware.h"
#include "mecabot_ros_config.h"

#define ENCODER_RESOLUTION		20

#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

float constraint(float var, float min, float max)
{
	if (var < min)	return min;
	if (var > max) 	return max;
	else 			return var;
}

uint32_t t;
uint16_t last_tick[4] = { 0, 0, 0, 0 };

extern Motor motor[4];
extern Encoder encoder[4];

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	comm_rosserial.set_tx_cplt();
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	comm_rosserial.reset_rbuf();
}

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	switch (htim->Channel)
	{
	case HAL_TIM_ACTIVE_CHANNEL_1:
		encoder[front_left]->tick++;
		break;
	case HAL_TIM_ACTIVE_CHANNEL_2:
		encoder[front_right]->tick++;
		break;
	case HAL_TIM_ACTIVE_CHANNEL_3:
		encoder[back_left]->tick++;
		break;
	case HAL_TIM_ACTIVE_CHANNEL_4:
		encoder[back_right]->tick++;
	default:
		break;
	}
}

void motorSpeedCallback(const std_msgs::UInt8& motor_speed_msg)
{
}

void commandVelocityCallback(const geometry_msgs::Twist& cmd_vel_msg)
{
	goal_vel[0] = cmd_vel_msg.linear.x;
	goal_vel[1] = cmd_vel_msg.linear.y;
	goal_vel[2] = cmd_vel_msg.angular.z;
}

void ros_setup()
{
	nh.initNode();
}

uint32_t millis()
{
	return HAL_GetTick();
}

void setup()
{
	ros_setup();

	mecabot_encoder_init();

	mecabot_motor_init();

	for (int i=0; i<NUM_OF_MOTOR; i++)
	{
		mecabot_motor_start(motor[i]);
	}
}

void loop()
{
	t = millis();

	/* Motor control */
	if ((t - t_previous[MOTOR_CONTROL_ID]) >= dt[MOTOR_CONTROL_ID])
	{
		calculateMotorSpeed();
		t_previous[MOTOR_CONTROL_ID] = t;
	}
	/* RPM publish */
	if ((t - t_previous[RPM_PUBLISH_ID]) >= dt[RPM_PUBLISH_ID])
	{

		t_previous[RPM_PUBLISH_ID] = t;
	}
	/* Odometry publish */

	nh.spinOnce();
}

uint16_t d_tick = 0;
float data = 0;

void updateRpm()
{
	for (int i=0; i<NUM_OF_MOTOR; i++)
	{
		d_tick = 0;
		// Encoder_UpdateTick(my_encoder);

		if (encoder[i]->tick < last_tick[i])
		{
			d_tick = encoder[i]->tick + (0xFFFF - last_tick[i]);
		}
		else
		{
			d_tick = encoder[i]->tick - last_tick[i];
		}
		last_tick[i] = encoder[i]->tick;

		// Get the number of rotation
		data = (float)d_tick / ENCODER_RESOLUTION;
		// Get the rotation per second
		data = (data * 1000) / dt[RPM_PUBLISH_ID];
		// Get the rotation per minute
		//data *= 60;

		rpm_msg.data = (uint32_t)(data*60);
	}
}

void publishRpmMsg()
{
	pub_motor_rpm.publish(&rpm_msg);
}

void calculateOdometry()
{
	float wheel_l, wheel_r;      // rotation value of wheel [rad]
	float delta_s, theta, delta_theta;
	static float last_theta = 0.0f;
	float v, w;                  // v = translational velocity [m/s], w = rotational velocity [rad/s]
	float step_time;

	wheel_l = wheel_r = 0.0f;
	delta_s = delta_theta = theta = 0.0f;
	v = w = 0.0f;
	step_time = 0.0f;

	step_time = diff_time;

	if (step_time == 0)
		return false;

	wheel_l = TICK2RAD * (float)last_diff_tick[LEFT];
	wheel_r = TICK2RAD * (float)last_diff_tick[RIGHT];

	if (isnan(wheel_l))
		wheel_l = 0.0f;

	if (isnan(wheel_r))
		wheel_r = 0.0f;

	delta_s     = WHEEL_RADIUS * (wheel_r + wheel_l) / 2.0f;
//     theta = WHEEL_RADIUS * (wheel_r - wheel_l) / WHEEL_SEPARATION;

	float quat_data[4];
	robot_imu_get_quat(quat_data);
	theta = atan2f(quat_data[0] * quat_data[3] + quat_data[1] * quat_data[2], 0.5f - quat_data[2] * quat_data[2] - quat_data[3] * quat_data[3]);
	delta_theta = theta - last_theta;

	// compute odometric pose
	odom_pose[0] += delta_s * cos(odom_pose[2] + (delta_theta / 2.0));
	odom_pose[1] += delta_s * sin(odom_pose[2] + (delta_theta / 2.0));
	odom_pose[2] += delta_theta;

	// compute odometric instantaneouse velocity

	v = delta_s / step_time;
	w = delta_theta / step_time;

	odom_vel[0] = v;
	odom_vel[1] = 0.0;
	odom_vel[2] = w;

	last_velocity[LEFT]  = wheel_l / step_time;
	last_velocity[RIGHT] = wheel_r / step_time;
	last_theta = theta;

	return true;
}

void calculateMotorSpeed()
{
	float linear_vel = goal_vel[0];
	float angular_vel = goal_vel[2];

	float left_motor_vel = linear_vel - (angular_vel * WHEEL_SEPARATION_Y / 2);
	float right_motor_vel = linear_vel + (angular_vel * WHEEL_SEPARATION_Y / 2);



	motor_speed[front_left] = (uint8_t)(left_motor_vel / ROBOT_MAX_ANGULAR_VELOCITY)
}
